namespace MinApiLib.Endpoints;

[Generator]
public class EndpointSourceGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
        // No initialization required for this one
    }

    public void Execute(GeneratorExecutionContext context)
    {
        CreateEndpointsMapper(context);
    }

    private static void CreateEndpointsMapper(GeneratorExecutionContext context)
    {
        var endpoints = context
                .Compilation
                .SourceModule
                .ReferencedAssemblySymbols
                .Prepend(context.Compilation.Assembly)
                .SelectMany(ForAssembly)
                .Where(n => n.AllInterfaces.Any(x => x.Name == "IEndpoint" && x.ContainingAssembly.Name == "MinApiLib.Endpoints"))
                .ToImmutableHashSet<INamedTypeSymbol>(SymbolEqualityComparer.Default);

        // Build up the source code
        var sb = new StringBuilder();
        sb.AppendLine($@"// <auto-generated/>");
        sb.AppendLine($@"namespace MinApiLib.Endpoints;");
        sb.AppendLine();
        sb.AppendLine($@"internal static class MinApiLibExtensions");
        sb.AppendLine($@"{{");
        sb.AppendLine($@"   public static RouteGroupBuilder MapAotEndpoints(this IEndpointRouteBuilder endpoints)");
        sb.AppendLine($@"   {{");
        sb.AppendLine($@"        var group = endpoints.MapGroup(""/"");");
        foreach (var one in endpoints)
        {
            var name = $"{GetNamespaceName(one.ContainingNamespace)}.{one.Name}";
            sb.AppendLine($"        group.MapEndpoint<{name}>();");
        }

        sb.AppendLine($@"       return group;");
        sb.AppendLine($@"   }}");
        sb.AppendLine($@"}}");

        // Add the source code to the compilation
        context.AddSource("MinApiLibExtensions.g.cs", sb.ToString());
    }

    private static IImmutableSet<INamedTypeSymbol> ForAssembly(IAssemblySymbol assembly)
    {
        return GetAllNamespaces(assembly.GlobalNamespace)
            .SelectMany(ns => ns.GetTypeMembers())
            .SelectMany(t => AllNestedTypesAndSelf(t))
            .Where(nts => nts is
            {
                IsAbstract: false,
                IsStatic: false,
                IsImplicitClass: false,
                IsScriptClass: false,
                TypeKind: TypeKind.Class or TypeKind.Struct or TypeKind.Structure,
                DeclaredAccessibility: Accessibility.Public or Accessibility.Internal or Accessibility.ProtectedOrInternal
            })
            .ToImmutableHashSet<INamedTypeSymbol>(SymbolEqualityComparer.Default);
    }

    private static IEnumerable<INamedTypeSymbol> AllNestedTypesAndSelf(INamedTypeSymbol type)
    {
        yield return type;
        foreach (var typeMember in type.GetTypeMembers())
        {
            foreach (var nestedType in AllNestedTypesAndSelf(typeMember))
            {
                yield return nestedType;
            }
        }
    }

    private static IEnumerable<INamespaceSymbol> GetAllNamespaces(INamespaceSymbol root)
    {
        yield return root;
        foreach (var child in root.GetNamespaceMembers())
            foreach (var next in GetAllNamespaces(child))
                yield return next;
    }

    private static string GetNamespaceName(INamespaceSymbol @namespace)
    {
        var name = @namespace.Name;
        if (@namespace.ContainingNamespace is not null)
        {
            var parent = GetNamespaceName(@namespace.ContainingNamespace);
            if (!string.IsNullOrWhiteSpace(parent))
            {
                return $"{parent}.{name}";
            }
        }

        return name;
    }
}
